【进程】
.exe 不能叫程序，只是一个文件
程序，去运行1个.exe，在内存中操作系统开始执行它了，叫做进程
后台进程  前台进程
Word是进程方式执行的，前台进程
MySQL是后台方式执行的，后台进程

【线程】
打开迅雷 –> 起一条进程 -> 迅雷可以同时下载多个文件每下载的一个文件条线就是一个线程
有的程序可以起多个进程

1个进程可以有多个相互独立的线程最大发挥【多核心CPU】的性能

【CPU执行任务】
在一个时刻，一颗CPU只能执行一个任务
一颗CPU轮询执行多个任务就是【并发】
多颗CPU轮询执行多个任务就是【并行】
现在传统的语言，多任务就是分配在一颗CPU上，多核心不能发挥

Golang支持并行和并发

【协程Go主程】
最早的程序没有并发和并行，一个进程打天下 --> 线程发挥CPU能力 能做到并发了
硬件发展比软件发展快
但是线程还是比较吃资源，占用CPU、内存比较多，有些地方还是物理态的，比较笨拙

【Golang协程】
1.能否让CPU全部参与工作，CPU有8个核心就把任务分配给8个核心同时并行
2.线程还是偏重底层优化做成逻辑态的编译器优化算法优化，让线程变得更加轻巧，
CPU、内存占用更小了，引出协程

Go主线程类似于传统语言的进程
跑一个主线程，里面有多个协程
Golang轻轻松松可以起上万个协程，非常稳定
主线程里面可以跑多个协程goroutine

编译器把原来线程中很多可以共享的东西拿过来共享给协程，协程更轻量级

【Go协程特点】
1.有独立栈空间
2.共享程序对空间
3.调度由程序员控制 go 关键字
4.逻辑态轻量级编译器优化的轻量级线程

【主线程】
物理线程，直接作用在CPU上，重量级 + 物理态 非常耗费CPU资源

【协程】
编译器从主线程逻辑出的逻辑态协程，轻量级 + 逻辑态 CPU耗费小

其他语言的并发机制一般基于【物理态的线程】开启过多的物理线程资源耗费大
凸显Golang在并发上的优势

【设置Golang运行的CPU数 runtime】
cpuNum := runtime.NumCPU()
runtime.GOMAXPROCS(cpuNum)

程序的运行与退出以主线程的运行与退出为准
1.如果主线程退出了，则协程即使没有执行完毕也会退出
2.主线程没退出，协程执行完任务就自己退出
主线程什么时候退出，协程什么时候结束，需要一个【通信机制】

【goroutine并发并行数据抢夺问题】
# 编译发现多个goroutine并发并行抢夺同一个资源的竞争race情况
go build -race main.go

【全局的互斥锁】
声明一个全局的互斥锁
lock sync.Mutex sync synchornized 同步 Mutex 互斥

var (
	myMap = make(map[int]int, 10)
	lock sync.Mutex
)

//加锁
lock.Lock()
myMap[n] = res
//解锁
lock.Unlock()

lock.Lock()
for i, v := range myMap {
	fmt.Printf("map[%d]=%d\n", i, v)
}
lock.Unlock()

协程1拿到锁，继续执行操作myMap，执行完解锁
协程2来了，看锁是否加上的，协程2就被Go底层放到【队列中等待】
协程3来了，一看锁还加着【队列中等待】
协程4来了，协程1还加着锁【队列中等待】
协程1执行完毕，解锁，【底层有一种机制，从协程队列取出排队在最前面的协程去执行】
如果其他的协程等这把锁一直没等到，就会【超时】

【channel】
使用【全局变量myMap】+【sync.Mutex锁同步】解决goroutine通信可行，但不完美
1.主线程等待所有goroutine全部完成的时间很难确定，手动sleep时间段仅仅是人的估算
2.实际上没有利用多个协程对全局变量的读写操作，还是回归到了串行

channel 引用传递 队列 先进先出 协程安全 多goroutine访问不需要加锁
intChan 的值=0xc04207a000 intChan本身的地址=0xc042068018
intChan==0xc042068018 存储 [ 0xc04207a000 ]
把一个channel传到一个函数中，操作的是同一个channel，引用类型

管道：取最前面的，【取完后长度减少】
intChan <- item
数据在管道尾部追加
channel 和 map 不同，Map会自动增长键值对，channel不能自动增长
容量是make指定的，管道在make后容量不会变化
管道的价值在于 边放边取
channel执行了pop操作len减少cap不变
channel的cap在push满后就不能再放入元素了
channel关闭后只可读不可写 panic:send on closed channel
未关闭pop掉所有元素后继续pop则deadlock

把管道存储的类型声明为 空接口 就可以放 多态数组
存放任意类型的channel
allChan := make(chan interface{}, 3)

【类型断言】
// 下面的写法是错误的!编译不通过
// 在编译的层面 认为 newCat 是空接口类型 接口类型里面是没有字段
// 编译层面 =/= 运行层面
// fmt.Printf("newCat.Name=%v", newCat.Name)

//使用类型断言
a := newCat.(Cat)
fmt.Printf("newCat.Name=%v", a.Name)

【channel遍历】
普通for循环 for i := 0; i < len(channel); i++ {
这样遍历只能取出 len(channel)/2 个元素 因为每 pop 1个元素 len会减去1
容量遍历也不行，容量也不能代表管道有多少个数据
所以channel遍历不能使用普通for循环 要使用 for...range...

如果不关闭管道一直遍历 for v := range channel { 会出现deadlock的错误
fatal error : all goroutines are asleep - deadlock!

如果channel已经关闭，则会正常遍历数据，遍历完后，就会退出遍历
close(channel)
for v := range channel { 正常运行不会deadlock

